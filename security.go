package openapi

import "strconv"

// SecuritySchemeType represents the type of the security scheme.
type SecuritySchemeType string

func (ss SecuritySchemeType) String() string {
	return string(ss)
}

const (
	// SecuritySchemeTypeAPIKey = "apiKey"
	SecuritySchemeTypeAPIKey SecuritySchemeType = "apiKey"
	// SecuritySchemeTypeHTTP = "http"
	SecuritySchemeTypeHTTP SecuritySchemeType = "http"
	// SecuritySchemeTypeMutualTLS = mutualTLS
	SecuritySchemeTypeMutualTLS SecuritySchemeType = "mutualTLS"
	// SecuritySchemeTypeOAuth2 = oauth2
	SecuritySchemeTypeOAuth2 SecuritySchemeType = "oauth2"
	// SecuritySchemeTypeOpenIDConnect = "openIdConnect"
	SecuritySchemeTypeOpenIDConnect SecuritySchemeType = "openIdConnect"
)

// TODO: make SecurityRequirement an ordered slice.

// SecurityRequirements is a list of SecurityRequirement
type SecurityRequirements struct {
	Items []*SecurityRequirement

	Location *Location
}

func (sr *SecurityRequirements) setLocation(loc Location) error {
	if sr == nil {
		return nil
	}
	sr.Location = &loc
	for i, item := range sr.Items {
		if err := item.setLocation(loc.Append(strconv.Itoa(i))); err != nil {
			return err
		}
	}
	return nil
}

type SecurityRequirementItem struct {
	Key      Text
	Value    Text
	Location *Location
}

// SecurityRequirement lists the required security schemes to execute this
// operation. The name used for each property MUST correspond to a security
// scheme declared in the Security Schemes under the Components Object.
//
// Security Requirement Objects that contain multiple schemes require that all
// schemes MUST be satisfied for a request to be authorized. This enables
// support for scenarios where multiple query parameters or HTTP headers are
// required to convey security information.
//
// When a list of Security Requirement Objects is defined on the OpenAPI Object
// or Operation Object, only one of the Security Requirement Objects in the list
// needs to be satisfied to authorize the request.
//
// Each name MUST correspond to a security scheme which is declared in the
// Security Schemes under the Components Object. If the security scheme is of
// type "oauth2" or "openIdConnect", then the value is a list of scope names
// required for the execution, and the list MAY be empty if authorization does
// not require a specified scope. For other security scheme types, the array MAY
// contain a list of role names which are required for the execution, but are
// not otherwise defined or exchanged in-band.
type SecurityRequirement struct {
	Items []*SecurityRequirementItem `json:"-"`

	Location *Location `json:"-"`
}

func (sr *SecurityRequirementItem) setLocation(loc Location) error {
	sr.Location = &loc
	return nil
}

func (sr *SecurityRequirement) setLocation(loc Location) error {
	if sr == nil {
		return nil
	}
	sr.Location = &loc
	for _, item := range sr.Items {
		if err := sr.setLocation(loc.Append(item.Key.String())); err != nil {
			return err
		}
	}
	return nil
}

func (sr SecurityRequirement) Get(key Text) *SecurityRequirementItem {
	for _, item := range sr.Items {
		if item.Key == key {
			return item
		}
	}
	return nil
}

func (sr SecurityRequirement) Has(key Text) bool {
	for _, item := range sr.Items {
		if item.Key == key {
			return true
		}
	}
	return false
}

func (sr *SecurityRequirement) Set(key Text, value Text) {
	if sr == nil {
		return
	}
	for _, item := range sr.Items {
		if item.Key == key {
			item.Value = value
			return
		}
	}
	sr.Items = append(sr.Items, &SecurityRequirementItem{
		Key:   key,
		Value: value,
	})
}

func (sr *SecurityRequirement) Del(key Text) {
	if sr == nil {
		return
	}
	for i, item := range sr.Items {
		if item.Key == key {
			sr.Items = append(sr.Items[:i], sr.Items[i+1:]...)
			return
		}
	}
}

// SecuritySchemeMap is a map of SecurityScheme
type SecuritySchemeMap = ComponentMap[*SecurityScheme]

// SecurityScheme defines a security scheme that can be used by the operations.
type SecurityScheme struct {
	// The type of the security scheme.
	//
	// *required
	Type SecuritySchemeType `json:"type,omitempty"`

	// Any description for security scheme. CommonMark syntax MAY be used for
	// rich text representation.
	Description Text `json:"description,omitempty"`
	// The name of the header, query or cookie parameter to be used.
	//
	// Applies to: API Key
	//
	// 	*required*
	Name Text `json:"name,omitempty"`
	// The location of the API key. Valid values are "query", "header" or "cookie".
	//
	// Applies to: APIKey
	//
	// 	*required*
	In In `json:"in,omitempty"`
	// The name of the HTTP Authorization scheme to be used in the Authorization
	// header as defined in RFC7235. The values used SHOULD be registered in the
	// IANA Authentication Scheme registry.
	//
	// 	*required*
	Scheme Text `json:"scheme,omitempty"`

	// http ("bearer")  A hint to the client to identify how the bearer token is
	// formatted. Bearer tokens are usually generated by an authorization
	// server, so this information is primarily for documentation purposes.
	BearerFormat Text `json:"bearerFormat,omitempty"`

	// An object containing configuration information for the flow types supported.
	//
	// 	*required*
	Flows *OAuthFlows `json:"flows,omitempty"`

	// OpenId Connect URL to discover OAuth2 configuration values. This MUST be
	// in the form of a URL. The OpenID Connect standard requires the use of
	// TLS.
	//
	// 	*required*
	OpenIDConnectURL Text `json:"openIdConnect,omitempty"`

	Extensions `json:"-"`
	Location   *Location `json:"-"`
}

func (s *SecurityScheme) setLocation(loc Location) error {
	if s == nil {
		return nil
	}
	s.Location = &loc
	return s.Flows.setLocation(loc.Append("flows"))
}

// UnmarshalJSON unmarshals JSON
func (ss *SecurityScheme) UnmarshalJSON(data []byte) error {
	type securityscheme SecurityScheme

	var v securityscheme
	err := unmarshalExtendedJSON(data, &v)
	*ss = SecurityScheme(v)
	return err
}

// MarshalJSON marshals JSON
func (ss SecurityScheme) MarshalJSON() ([]byte, error) {
	type securityscheme SecurityScheme

	return marshalExtendedJSON(securityscheme(ss))
}

func (*SecurityScheme) Kind() Kind      { return KindSecurityScheme }
func (*SecurityScheme) mapKind() Kind   { return KindSecuritySchemeMap }
func (*SecurityScheme) sliceKind() Kind { return KindUndefined }

var _ node = (*SecurityScheme)(nil)
